from fastapi import APIRouter, HTTPException
from app.utils.database import db
from app.generator.algorithms.ga.ga import *
from app.generator.algorithms.co.co_v2 import *
# from app.generator.rl.rl_train import *
from app.generator.rl.rl import generate_rl
from app.generator.eval.eval import evaluate as evaluate_timetables
from app.Services.timetable_notification import create_timetable_notification
from app.models.published_timetable_model import PublishedTimetable, Source, TimetableEntry
import logging
from bson import ObjectId
import threading
import logging
from datetime import datetime
from typing import Optional, List, Dict
import os
from openai import OpenAI
from pydantic import BaseModel 

# Global variable to track generation status
generation_status = {
    "in_progress": False,
    "completed": False,
    "success_count": 0,
    "algorithms_completed": 0,
    "start_time": None,
    "last_log": "",
    "logs": []
}

def reset_generation_status():
    """Reset the generation status to default values"""
    global generation_status
    generation_status.update({
        "in_progress": False,
        "completed": False,
        "success_count": 0, 
        "algorithms_completed": 0,
        "start_time": None,
        "last_log": "",
        "logs": []
    })

def update_status(message, success=None, completed=None):
    """Update the generation status with new information"""
    global generation_status
    
    # Update the last log message
    generation_status["last_log"] = message
    
    # Add to logs array with timestamp
    log_entry = {
        "message": message,
        "timestamp": datetime.now().isoformat()
    }
    generation_status["logs"].append(log_entry)
    
    # If a success is reported, increment success count
    if success is not None:
        if success:
            generation_status["success_count"] += 1
        generation_status["algorithms_completed"] += 1
    
    # If completion is reported, mark as completed
    if completed is not None:
        generation_status["completed"] = completed
        if completed:
            generation_status["in_progress"] = False

router = APIRouter()

# Get OpenRouter API key from environment variables
openrouter_api_key = os.environ.get("OPENROUTER_API_KEY")
if not openrouter_api_key:
    logging.warning("OPENROUTER_API_KEY not found in environment variables. DeepSeek integration will not work.")

# Configure OpenAI client to use OpenRouter
client = OpenAI(
    api_key=openrouter_api_key,
    base_url="https://openrouter.ai/api/v1",
)

# Define common error messages as constants
NO_PUBLISHED_TIMETABLE = "No published timetable found"
NO_ACTIVE_PUBLISHED_TIMETABLE = "No active published timetable found"
SEMESTER_NOT_FOUND = "Semester not found in published timetable" 
ENTRY_INDEX_OUT_OF_RANGE = "Entry index is out of range"

class AlgorithmEvaluation(BaseModel):
    """Model for timetable algorithm evaluation input"""
    scores: Dict[str, Dict[str, float]]
    
    def validate_scores(self):
        """Validate that all algorithms have required metrics"""
        required_metrics = ["average_score", "conflicts", "room_utilization", "period_distribution"]
        
        for algorithm, metrics in self.scores.items():
            missing_metrics = [metric for metric in required_metrics if metric not in metrics]
            if missing_metrics:
                raise ValueError(f"Algorithm '{algorithm}' is missing required metrics: {missing_metrics}")
        
        return True

def evaluate():
    """
    Evaluate the timetables generated by different algorithms
    Returns a dictionary with algorithm names as keys and scores as values
    """
    # Use the dedicated evaluation module instead of simple calculation
    return evaluate_timetables()
    
def save_timetable(li, algorithm):
    """Save generated timetable to database with error handling"""
    # Don't try to save empty timetable data
    if not li:
        logging.warning(f"No timetable data to save for algorithm: {algorithm}")
        return False
        
    subgroups = [
        "SEM101", "SEM102", "SEM201", "SEM202",
        "SEM301", "SEM302", "SEM401", "SEM402"
    ]
    
    try:
        semester_timetables = {semester: [] for semester in subgroups}  

        for activity in li:
            # Make sure each activity has the algorithm field set
            if "algorithm" not in activity:
                activity["algorithm"] = algorithm
                
            subgroup_id = activity.get("subgroup", "SEM101")  # Default to SEM101 if not specified
            if subgroup_id in semester_timetables:
                semester_timetables[subgroup_id].append(activity)
            else:
                logging.warning(f"Unknown subgroup ID: {subgroup_id}")
                
        index = 0
        success = False
        
        for semester, activities in semester_timetables.items():
            try:
                result = db["Timetable"].replace_one(
                    {
                        "$and": [
                            {"semester": semester},
                            {"algorithm": algorithm}
                        ]
                    },
                    {
                        "code": generate_timetable_code(index, algorithm),
                        "algorithm": algorithm,
                        "semester": semester, 
                        "timetable": activities,
                        "published": False
                    },
                    upsert=True
                )
                if result.acknowledged:
                    success = True
                index += 1
            except Exception as e:
                logging.error(f"Failed to save timetable for semester {semester}: {str(e)}")
                
        return success
    except Exception as e:
        logging.error(f"Failed to save timetable for {algorithm}: {str(e)}")
        return False

#generate unique timetable codes for each algorithm and semester       
def generate_timetable_code(index, algorithm):
    return f"{algorithm}-TT000{index}"

@router.post("/generate")
async def generate_timetable():
    logger = logging.getLogger(__name__)
    
    # Reset generation status
    reset_generation_status()
    generation_status["in_progress"] = True
    generation_status["start_time"] = datetime.now().isoformat()
    
    # Create a thread to run the timetable generation
    def generate():
        logger = logging.getLogger(__name__)
        logger.info("Starting timetable generation with multiple algorithms")
        update_status("Starting timetable generation with multiple algorithms")
        
        # Track algorithm results
        results = {"GA": False, "CO": False, "RL": False}
        
        # Run GA
        try:
            logger.info("Starting genetic algorithm (GA)...")
            update_status("Starting genetic algorithm (GA)...")
            
            ga_result = generate_ga()
            # GA returns (pop, log, hof, formatted_solution) - we need the 4th element
            if ga_result and len(ga_result) >= 4:
                timetable_data = ga_result[3]  # formatted_solution
                if timetable_data and save_timetable(timetable_data, "GA"):
                    results["GA"] = True
                    logger.info("GA algorithm completed successfully")
                    update_status("GA algorithm completed successfully", success=True)
                    create_timetable_notification("GA", True)
                else:
                    results["GA"] = False
                    logger.warning("GA algorithm completed but failed to save timetable")
                    update_status("GA algorithm completed but failed to save timetable", success=False)
                    create_timetable_notification("GA", False)
            else:
                results["GA"] = False
                logger.warning("GA algorithm completed with no result")
                update_status("GA algorithm completed with no result", success=False)
                create_timetable_notification("GA", False)
                
        except Exception as e:
            results["GA"] = False
            logger.error(f"GA algorithm failed: {str(e)}")
            update_status(f"GA algorithm failed: {str(e)}", success=False)
            create_timetable_notification("GA", False)
            
        # Run Constraint Optimization
        try:
            logger.info("Starting constraint optimization (CO)...")
            update_status("Starting constraint optimization (CO)...")
            
            co_result = generate_co()
            # CO returns formatted_solution directly
            if co_result and save_timetable(co_result, "CO"):
                results["CO"] = True
                logger.info("CO algorithm completed successfully")
                update_status("CO algorithm completed successfully", success=True)
                create_timetable_notification("CO", True)
            else:
                results["CO"] = False
                logger.warning("CO algorithm completed with no result or failed to save")
                update_status("CO algorithm completed with no result or failed to save", success=False)
                create_timetable_notification("CO", False)
                
        except Exception as e:
            results["CO"] = False
            logger.error(f"CO algorithm failed: {str(e)}")
            update_status(f"CO algorithm failed: {str(e)}", success=False)
            create_timetable_notification("CO", False)
            
        # Run Reinforcement Learning
        try:
            logger.info("Starting reinforcement learning (RL)...")
            update_status("Starting reinforcement learning (RL)...")
            
            rl_result = generate_rl()
            # RL returns schedule directly
            if rl_result and save_timetable(rl_result, "RL"):
                results["RL"] = True
                logger.info("RL algorithm completed successfully")
                update_status("RL algorithm completed successfully", success=True)
                create_timetable_notification("RL", True)
            else:
                results["RL"] = False
                logger.warning("RL algorithm completed with no result or failed to save")
                update_status("RL algorithm completed with no result or failed to save", success=False)
                create_timetable_notification("RL", False)
                
        except Exception as e:
            results["RL"] = False
            logger.error(f"RL algorithm failed: {str(e)}")
            update_status(f"RL algorithm failed: {str(e)}", success=False)
            create_timetable_notification("RL", False)
            
        # Count successful algorithms
        successful_count = sum(1 for result in results.values() if result)
        
        # Run evaluation if any algorithms succeeded
        if successful_count > 0:
            try:
                logger.info("Starting timetable evaluation...")
                update_status("Starting timetable evaluation...")
                
                evaluation_scores = evaluate_timetables()
                
                if evaluation_scores:
                    # Save evaluation results to database
                    evaluation_doc = {
                        "timestamp": datetime.now(),
                        "scores": dict(evaluation_scores),
                        "algorithms_evaluated": list(evaluation_scores.keys())
                    }
                    
                    # Replace any existing evaluation (keep only the latest)
                    db["Evaluations"].delete_many({})
                    db["Evaluations"].insert_one(evaluation_doc)
                    
                    logger.info("Timetable evaluation completed and saved")
                    update_status("Timetable evaluation completed")
                else:
                    logger.warning("Evaluation completed but no scores generated")
                    update_status("Evaluation completed with no scores")
                    
            except Exception as e:
                logger.error(f"Evaluation failed: {str(e)}")
                update_status(f"Evaluation failed: {str(e)}")
        
        # Mark generation as complete
        final_message = f"Schedule generated successfully with {successful_count} of 3 algorithms"
        logger.info(final_message)
        update_status(final_message, completed=True)
            
    # Start the generation thread
    thread = threading.Thread(target=generate)
    thread.daemon = True
    thread.start()
    
    return {"message": "Timetable generation in progress..."}

@router.get("/generation-status")
async def get_generation_status():
    """Get the current status of the timetable generation process"""
    global generation_status
    return generation_status

@router.get("/timetables")
async def get_timetables():
    try:
        timetable_documents = list(db["Timetable"].find())
        
        # Filter out fields that can't be serialized to JSON
        clean_timetables = [clean_mongo_documents(doc) for doc in timetable_documents]
        
        # also get the latest evaluations from the eval collection
        evaluations_doc = db["Evaluations"].find_one(sort=[("_id", -1)])
        evaluations = clean_mongo_documents(evaluations_doc) if evaluations_doc else None
        
        return {"timetables": clean_timetables, "eval": evaluations}
    except Exception as e:
        logging.error(f"Failed to get timetables: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get timetables: {str(e)}")

@router.get("/notifications")
async def get_notifications():
    """Get all timetable-related notifications"""
    try:
        # Check if notifications collection exists, create it if not
        if "notifications" not in db.list_collection_names():
            db.create_collection("notifications")
            
        notifications = list(db["notifications"].find())
        # Clean MongoDB ObjectId fields for JSON serialization
        for notification in notifications:
            if "_id" in notification:
                notification["_id"] = str(notification["_id"])
                
        return notifications
    except Exception as e:
        logging.error(f"Error retrieving notifications: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve notifications: {str(e)}")

@router.put("/notifications/mark-all-read")
async def mark_all_notifications_read():
    """Mark all notifications as read"""
    try:
        # First check if there are any unread notifications
        unread_count = db["notifications"].count_documents({"read": False})
        
        if unread_count == 0:
            return {"success": True, "modified_count": 0, "message": "No unread notifications found"}
            
        # Update all unread notifications
        db["notifications"].update_many(
            {"read": False},
            {"$set": {"read": True}}
        )
        
        return {
            "success": True, 
            "modified_count": unread_count,
            "matched_count": unread_count
        }
    except Exception as e:
        logging.error(f"Error marking all notifications as read: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.put("/notifications/{notification_id}")
async def mark_notification_read(notification_id: str):
    """Mark a notification as read"""
    try:
        from bson import ObjectId
        db["notifications"].update_one(
            {"_id": notification_id},
            {"$set": {"read": True}}
        )
        
        return {"message": "Notification marked as read"}
    except Exception as e:
        logging.error(f"Error updating notification: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to update notification: {str(e)}")

@router.post("/select")
async def select_algorithm(algorithm: dict):
    """Endpoint to select an algorithm as the preferred one"""
    try:
        # Get the algorithm name from the request
        algorithm_name = algorithm.get("algorithm")
        if not algorithm_name:
            raise HTTPException(status_code=400, detail="Algorithm name is required")
            
        # Validate that it's one of our supported algorithms
        if algorithm_name not in ["GA", "CO", "RL"]:
            raise HTTPException(status_code=400, detail="Invalid algorithm. Must be one of: GA, CO, RL")
            
        # Check if we already have a selection document
        selection_exists = db["AlgorithmSelection"].find_one()
        
        if selection_exists:
            # Update existing selection
            db["AlgorithmSelection"].update_one(
                {"_id": selection_exists["_id"]},
                {"$set": {"selected_algorithm": algorithm_name}}
            )
        else:
            # Create new selection
            db["AlgorithmSelection"].insert_one(
                {"selected_algorithm": algorithm_name}
            )
            
        return {"message": f"Selected algorithm: {algorithm_name}", "success": True}
        
    except Exception as e:
        logging.error(f"Error selecting algorithm: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error selecting algorithm: {str(e)}")

@router.get("/selected")
async def get_selected_algorithm():
    try:
        # Changed from Settings to AlgorithmSelection to match where the data is stored
        data = db["AlgorithmSelection"].find_one()
        if data:
            return {"selected_algorithm": data.get("selected_algorithm", None)}
        else:
            return {"selected_algorithm": None}
    except Exception as e:
        logging.error(f"Failed to get selected algorithm: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get selected algorithm: {str(e)}")

# Published Timetable Endpoints

@router.post("/publish")
async def publish_timetable(algorithm: str):
    """
    Create a published timetable from the selected algorithm's timetables.
    This timetable becomes the active one for faculty and students.
    """
    try:
        # Get current user for tracking
        # In a real app, get this from auth context
        current_user_id = "admin"  # Placeholder
        
        # Find all timetables for the selected algorithm
        timetables = list(db["Timetable"].find({"algorithm": algorithm}))
        
        if not timetables:
            raise HTTPException(
                status_code=404, 
                detail=f"No timetables found for algorithm {algorithm}"
            )
        
        # Organize by semester
        semesters = {}
        timetable_ids = []
        
        for timetable in timetables:
            semester = timetable["semester"]
            timetable_ids.append(str(timetable["_id"]))
            semesters[semester] = timetable["timetable"]
        
        # Archive any existing active timetable
        db["PublishedTimetable"].update_many(
            {"status": "active"},
            {"$set": {"status": "archived"}}
        )
        
        # Reset published flag on all timetables
        db["Timetable"].update_many(
            {},
            {"$set": {"published": False}}
        )
        
        # Create source info
        source = {
            "algorithm": algorithm,
            "timetable_ids": timetable_ids
        }
        
        # Create new published timetable
        published_timetable = {
            "version": 1,
            "status": "active",
            "published_date": datetime.now(),
            "published_by": current_user_id,
            "source": source,
            "semesters": semesters,
        }
        
        # Insert the new published timetable
        db["PublishedTimetable"].insert_one(published_timetable)
        
        # Update the published flag in the Timetable collection
        db["Timetable"].update_many(
            {"algorithm": algorithm},
            {"$set": {"published": True}}
        )
        
        create_timetable_notification(algorithm, True)
        
        return {
            "success": True,
            "message": f"Timetable from {algorithm} algorithm published successfully",
            "id": str(published_timetable["_id"])
        }
        
    except HTTPException as http_ex:
        # Re-raise HTTP exceptions
        raise http_ex
    except Exception as e:
        logging.error(f"Failed to publish timetable: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to publish timetable: {str(e)}")

@router.get("/published")
async def get_published_timetable():
    """
    Get the active published timetable.
    This is the full timetable for all semesters.
    """
    try:
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            return {"message": NO_ACTIVE_PUBLISHED_TIMETABLE}
        
        # Clean MongoDB-specific fields
        published = clean_mongo_documents(published)
        
        return published
        
    except Exception as e:
        logging.error(f"Failed to get published timetable: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get published timetable: {str(e)}")

@router.get("/published/faculty/{faculty_id}")
async def get_faculty_timetable(faculty_id: str):
    """
    Get the published timetable filtered for a specific faculty member.
    Returns only classes where the faculty is teacher or substitute.
    """
    try:
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            return {"message": NO_ACTIVE_PUBLISHED_TIMETABLE}
        
        # Filter entries for this faculty
        faculty_timetable = {}
        
        for semester, entries in published["semesters"].items():
            faculty_entries = []
            
            for entry in entries:
                # Include if faculty is teacher or substitute
                if entry.get("teacher") == faculty_id or entry.get("substitute") == faculty_id:
                    faculty_entries.append(entry)
            
            if faculty_entries:
                faculty_timetable[semester] = faculty_entries
        
        # Clean MongoDB-specific fields
        result = {
            "_id": str(published["_id"]),
            "version": published["version"],
            "published_date": published["published_date"],
            "semesters": faculty_timetable
        }
        
        return result
        
    except Exception as e:
        logging.error(f"Failed to get faculty timetable: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get faculty timetable: {str(e)}")

@router.get("/published/student/{semester}")
async def get_student_timetable(semester: str):
    """
    Get the published timetable filtered for a specific student semester/subgroup.
    Returns only classes for the specified semester.
    """
    try:
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            return {"message": NO_ACTIVE_PUBLISHED_TIMETABLE}
        
        # Get entries for this semester
        semester_entries = published["semesters"].get(semester, [])
        
        # Clean MongoDB-specific fields
        result = {
            "_id": str(published["_id"]),
            "version": published["version"],
            "published_date": published["published_date"],
            "semester": semester,
            "entries": semester_entries
        }
        
        return result
        
    except Exception as e:
        logging.error(f"Failed to get student timetable: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get student timetable: {str(e)}")

@router.put("/published/entry")
async def update_timetable_entry(
    semester: str,
    entry_index: int,
    room: Optional[Dict] = None,
    teacher: Optional[str] = None,
    period: Optional[List[Dict]] = None,
    day: Optional[Dict] = None,
    subject: Optional[str] = None
):
    """
    Update a specific entry in the published timetable.
    This allows administrators to correct errors or make changes to any field.
    """
    try:
        # Get current user for tracking
        # In a real app, get this from auth context
        current_user_id = "admin"  # Placeholder
        
        # Find active published timetable
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            raise HTTPException(status_code=404, detail=NO_ACTIVE_PUBLISHED_TIMETABLE)
        
        # Check if semester exists
        if semester not in published["semesters"]:
            raise HTTPException(
                status_code=404, 
                detail=SEMESTER_NOT_FOUND
            )
        
        # Check if entry index is valid
        if entry_index < 0 or entry_index >= len(published["semesters"][semester]):
            raise HTTPException(
                status_code=404, 
                detail=ENTRY_INDEX_OUT_OF_RANGE
            )
        
        # Get the entry to update
        entry = published["semesters"][semester][entry_index]
        
        # Store the original teacher in the entry if not already present
        if "original_teacher" not in entry:
            entry["original_teacher"] = entry.get("teacher", "Unknown")
        
        # Prepare modification record
        modification = {
            "modified_at": datetime.now(),
            "modified_by": current_user_id,
            "reason": "Administrative update" 
        }
        
        # Update fields if provided
        update_fields = {}
        
        if room is not None:
            update_fields[f"semesters.{semester}.{entry_index}.room"] = room
            
        if teacher is not None:
            update_fields[f"semesters.{semester}.{entry_index}.teacher"] = teacher
            
        if period is not None:
            update_fields[f"semesters.{semester}.{entry_index}.period"] = period
            
        if day is not None:
            update_fields[f"semesters.{semester}.{entry_index}.day"] = day
            
        if subject is not None:
            update_fields[f"semesters.{semester}.{entry_index}.subject"] = subject
        
        # Add modification record
        update_fields[f"semesters.{semester}.{entry_index}.modification"] = modification
        
        # Increment version number
        update_fields["version"] = published["version"] + 1
        
        # Perform update
        db["PublishedTimetable"].update_one(
            {"_id": published["_id"]},
            {"$set": update_fields}
        )
        
        # Create notification about the timetable update
        create_timetable_notification("timetable_update", True)
        
        return {
            "success": True,
            "message": "Timetable entry updated successfully",
            "semester": semester,
            "entry_index": entry_index
        }
        
    except HTTPException as http_ex:
        # Re-raise HTTP exceptions
        raise http_ex
    except Exception as e:
        logging.error(f"Failed to update timetable entry: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to update timetable entry: {str(e)}")

@router.put("/published/substitute")
async def assign_substitute(
    semester: str,
    entry_index: int,
    substitute: str,
    reason: Optional[str] = None
):
    """
    Assign a substitute teacher to a specific timetable entry.
    This is used when a faculty member is unavailable for a class.
    """
    try:
        # Get the published timetable
        published = db["PublishedTimetable"].find_one({})
        if not published:
            raise HTTPException(status_code=404, detail=NO_PUBLISHED_TIMETABLE)
            
        # Validate semester exists in the published timetable
        if semester not in published["semesters"]:
            raise HTTPException(status_code=404, detail=SEMESTER_NOT_FOUND)
            
        # Validate entry_index is valid
        if entry_index < 0 or entry_index >= len(published["semesters"][semester]):
            raise HTTPException(status_code=404, detail=ENTRY_INDEX_OUT_OF_RANGE)
            
        # Get the entry to update
        entry = published["semesters"][semester][entry_index]
        
        # Store the original teacher in the entry if not already present
        if "original_teacher" not in entry:
            entry["original_teacher"] = entry.get("teacher", "Unknown")
        
        # Prepare modification record
        modification = {
            "modified_at": datetime.now(),
            "type": "substitute_assigned",
            "field": "teacher",
            "previous_value": entry.get("teacher"),
            "new_value": substitute,
            "reason": reason or "No reason provided"
        }
        
        # Update fields
        update_fields = {
            f"semesters.{semester}.{entry_index}.substitute": substitute,
            f"semesters.{semester}.{entry_index}.modification": modification,
            "version": published["version"] + 1
        }
        
        # If we have an original teacher recorded, we can restore it as the main teacher
        if "original_teacher" in entry and entry["original_teacher"]:
            update_fields[f"semesters.{semester}.{entry_index}.teacher"] = entry["original_teacher"]
        
        # Remove substitute and original_teacher fields
        update = {
            "$set": update_fields,
            "$unset": {
                f"semesters.{semester}.{entry_index}.substitute": "",
                f"semesters.{semester}.{entry_index}.original_teacher": ""
            }
        }
        
        # Perform update
        db["PublishedTimetable"].update_one(
            {"_id": published["_id"]},
            update
        )
        
        # Create notification about the substitution
        create_timetable_notification("substitute_assigned", True)
        
        return {
            "success": True,
            "message": "Substitute teacher assigned successfully",
            "semester": semester,
            "entry_index": entry_index,
            "substitute": substitute,
            "original_teacher": entry.get("original_teacher")
        }
        
    except HTTPException as http_ex:
        # Re-raise HTTP exceptions
        raise http_ex
    except Exception as e:
        logging.error(f"Failed to assign substitute teacher: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to assign substitute teacher: {str(e)}")

@router.put("/published/remove-substitute")
async def remove_substitute(
    semester: str,
    entry_index: int
):
    """
    Remove a substitute teacher from a specific timetable entry.
    This is used when the original faculty member becomes available again.
    """
    try:
        # Get current user for tracking
        # In a real app, get this from auth context
        current_user_id = "admin"  # Placeholder
        
        # Find active published timetable
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            raise HTTPException(status_code=404, detail=NO_ACTIVE_PUBLISHED_TIMETABLE)
        
        # Check if semester exists
        if semester not in published["semesters"]:
            raise HTTPException(
                status_code=404, 
                detail=SEMESTER_NOT_FOUND
            )
        
        # Check if entry index is valid
        if entry_index < 0 or entry_index >= len(published["semesters"][semester]):
            raise HTTPException(
                status_code=404, 
                detail=ENTRY_INDEX_OUT_OF_RANGE
            )
        
        # Get the entry to update
        entry = published["semesters"][semester][entry_index]
        
        # Check if there is a substitute to remove
        if "substitute" not in entry or not entry["substitute"]:
            return {
                "success": True,
                "message": "No substitute teacher to remove",
                "semester": semester,
                "entry_index": entry_index
            }
        
        # Prepare modification record
        modification = {
            "modified_at": datetime.now(),
            "modified_by": current_user_id,
            "reason": "Substitute teacher removed"
        }
        
        # Update fields - restore original teacher if available
        update_fields = {
            "version": published["version"] + 1,
            f"semesters.{semester}.{entry_index}.modification": modification
        }
        
        # If we have an original teacher recorded, we can restore it as the main teacher
        if "original_teacher" in entry and entry["original_teacher"]:
            update_fields[f"semesters.{semester}.{entry_index}.teacher"] = entry["original_teacher"]
        
        # Remove substitute and original_teacher fields
        update = {
            "$set": update_fields,
            "$unset": {
                f"semesters.{semester}.{entry_index}.substitute": "",
                f"semesters.{semester}.{entry_index}.original_teacher": ""
            }
        }
        
        # Perform update
        db["PublishedTimetable"].update_one(
            {"_id": published["_id"]},
            update
        )
        
        # Create notification about the substitution removal
        create_timetable_notification("substitute_removed", True)
        
        return {
            "success": True,
            "message": "Substitute teacher removed successfully",
            "semester": semester,
            "entry_index": entry_index
        }
        
    except HTTPException as http_ex:
        # Re-raise HTTP exceptions
        raise http_ex
    except Exception as e:
        logging.error(f"Failed to remove substitute teacher: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to remove substitute teacher: {str(e)}")

def analyze_algorithms_locally(scores: Dict[str, Dict[str, float]]) -> str:
    """
    Provide local analysis of algorithm performance when external API is unavailable.
    """
    try:
        # Filter to only GA, RL, CO algorithms
        target_algorithms = {k: v for k, v in scores.items() if k in ["GA", "RL", "CO"]}
        
        if not target_algorithms:
            return "No GA, RL, or CO algorithms found in the provided data."
        
        # Sort algorithms by average score (higher is better)
        sorted_algorithms = sorted(
            target_algorithms.items(), 
            key=lambda x: x[1].get("average_score", 0), 
            reverse=True
        )
        
        analysis = "## Algorithm Performance Analysis\n\n"
        analysis += "### How Timetable Evaluation Works:\n"
        analysis += "Timetable algorithms are evaluated based on multiple criteria:\n"
        analysis += "- **Average Score**: Composite fitness score considering all constraints\n"
        analysis += "- **Conflicts**: Number of scheduling conflicts (lower is better)\n"
        analysis += "- **Room Utilization**: Percentage of available rooms used efficiently\n"
        analysis += "- **Period Distribution**: How evenly classes are distributed across time slots\n\n"
        analysis += "**Note**: Timetable scores are typically 15-30 due to complex multi-objective optimization.\n"
        analysis += "Perfect scores (100+) are nearly impossible due to conflicting constraints.\n\n"
        
        # Best to Worst ranking
        analysis += "**Best to Worst Ranking:**\n"
        for i, (algo, metrics) in enumerate(sorted_algorithms, 1):
            score = metrics.get("average_score", 0)
            analysis += f"{i}. {algo} (Score: {score:.1f})\n"
        
        analysis += "\n**Algorithm Analysis:**\n"
        
        # Detailed analysis for each algorithm
        for algo, metrics in sorted_algorithms:
            score = metrics.get("average_score", 0)
            conflicts = metrics.get("conflicts", 0)
            room_util = metrics.get("room_utilization", 0)
            period_dist = metrics.get("period_distribution", 0)
            
            analysis += f"**{algo} Algorithm:** Score {score:.1f}, with {conflicts:.1f} conflicts, "
            analysis += f"{room_util:.1f}% room utilization, and {period_dist:.1f}% period distribution. "
            
            # Add performance assessment based on realistic timetable scoring
            # Note: Timetable scores are typically much lower than 100 due to complex constraints
            if score >= 25:
                analysis += "Excellent performance with superior constraint satisfaction.\n"
            elif score >= 20:
                analysis += "Very good performance with strong optimization.\n"
            elif score >= 15:
                analysis += "Good performance with acceptable constraint handling.\n"
            elif score >= 10:
                analysis += "Moderate performance with room for improvement.\n"
            else:
                analysis += "Poor performance requiring significant optimization.\n"
        
        # Recommendation
        best_algo, best_metrics = sorted_algorithms[0]
        analysis += f"\n### Recommendation:\n"
        analysis += f"**Primary Choice: {best_algo} Algorithm**\n"
        analysis += f"- Achieved highest composite score: {best_metrics.get('average_score', 0):.1f}\n"
        analysis += f"- Conflict count: {best_metrics.get('conflicts', 0):.1f} "
        
        if best_metrics.get("conflicts", 0) == 0:
            analysis += "(Perfect - no scheduling conflicts)\n"
        elif best_metrics.get("conflicts", 0) < 2:
            analysis += "(Excellent - minimal conflicts)\n"
        elif best_metrics.get("conflicts", 0) < 5:
            analysis += "(Good - acceptable conflict level)\n"
        else:
            analysis += "(Needs improvement - high conflict count)\n"
            
        analysis += f"- Room utilization: {best_metrics.get('room_utilization', 0):.1f}% "
        room_util = best_metrics.get('room_utilization', 0)
        if room_util > 15:
            analysis += "(Efficient space usage)\n"
        elif room_util > 10:
            analysis += "(Moderate space usage)\n"
        else:
            analysis += "(Conservative space usage)\n"
            
        analysis += f"- Period distribution: {best_metrics.get('period_distribution', 0):.1f}% "
        period_dist = best_metrics.get('period_distribution', 0)
        if period_dist >= 95:
            analysis += "(Excellent time slot distribution)\n"
        elif period_dist >= 85:
            analysis += "(Good time slot distribution)\n"
        else:
            analysis += "(Uneven time slot distribution)\n"
            
        # Add context about why this algorithm is recommended
        analysis += f"\n**Why {best_algo}?** "
        if best_algo == "GA":
            analysis += "Genetic Algorithm excels at finding globally optimal solutions through evolutionary search."
        elif best_algo == "RL":
            analysis += "Reinforcement Learning adapts well to complex constraints and learns optimal scheduling patterns."
        elif best_algo == "CO":
            analysis += "Ant Colony Optimization efficiently explores solution space using swarm intelligence."
        else:
            analysis += "This algorithm demonstrated superior performance across all evaluation metrics."
            
        return analysis
        
    except Exception as e:
        return f"Error in local analysis: {str(e)}"

@router.post("/evaluate-algorithms")
async def evaluate_algorithms(evaluation: AlgorithmEvaluation):
    """
    Evaluate timetable algorithms using DeepSeek V3 via OpenRouter with fallback to local analysis.
    
    This endpoint accepts evaluation scores for different algorithms and 
    returns an analysis and recommendation. If external API fails, provides local analysis.
    """
    try:
        # Validate input data
        evaluation.validate_scores()
        
        # Try external API first if available
        if openrouter_api_key:
            try:
                # Format the scores for the LLM prompt
                evaluation_summary = format_scores_for_api(evaluation.scores)
                
                prompt = f"""
The following are evaluation scores for different algorithms used in a timetable scheduling optimization project:
{evaluation_summary}

Based on these results, provide an analysis of ONLY the GA, RL, and CO algorithms in this format:
1. **Best to Worst:** List these three algorithms (GA, RL, CO) from best to worst based on their average scores
2. **Algorithm Analysis:** For each algorithm, provide a 1-2 sentence description including their EXACT NUMERIC VALUES from the data above (average_score, conflicts, room_utilization, period_distribution)
3. **Recommendation:** Provide a clear recommendation about which algorithm should be used and why

CRITICAL REQUIREMENTS:
- MUST include the exact numeric values (e.g., "GA: 17.4 score, 0.0 conflicts, 11.6% room utilization, 100.0% period distribution")
- Focus ONLY on GA (Genetic Algorithm), RL (Reinforcement Learning), and CO (Ant Colony Optimization) algorithms
- Do NOT mention PSO or BC algorithms
- Keep response under 200 words but include all specific numbers

Example format: "**GA Algorithm:** Score 17.4, with 0.0 conflicts and 11.6% room utilization, making it highly reliable..."
"""

                logging.info("Sending evaluation request to DeepSeek")
                
                # Call DeepSeek V3 via OpenRouter API
                completion = client.chat.completions.create(
                    model="deepseek/deepseek-chat:free",
                    messages=[
                        {
                            "role": "user",
                            "content": prompt
                        }
                    ],
                    temperature=0.7,
                    max_tokens=250
                )
                
                # Extract the response content
                response = completion.choices[0].message.content
                logging.info("Received response from DeepSeek")
                
                return {
                    "analysis": response,
                    "source": "external_api",
                    "status": "success"
                }
                
            except Exception as api_error:
                logging.warning(f"External API failed: {str(api_error)}")
                logging.info("Falling back to local analysis")
                
                # Fall back to local analysis
                local_analysis = analyze_algorithms_locally(evaluation.scores)
                return {
                    "analysis": local_analysis,
                    "source": "local_analysis",
                    "status": "fallback",
                    "api_error": str(api_error)
                }
        else:
            # No API key available, use local analysis
            logging.info("No OpenRouter API key available, using local analysis")
            local_analysis = analyze_algorithms_locally(evaluation.scores)
            return {
                "analysis": local_analysis,
                "source": "local_analysis",
                "status": "no_api_key"
            }
    
    except ValueError as ve:
        logging.error(f"Validation error: {str(ve)}")
        raise HTTPException(status_code=422, detail=f"Validation error: {str(ve)}")
    except Exception as e:
        logging.error(f"Error evaluating algorithms: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to evaluate algorithms: {str(e)}")

def format_scores_for_api(scores):
    """Format the algorithm evaluation scores for the LLM prompt"""
    formatted_text = ""
    
    for algorithm, metrics in scores.items():
        formatted_text += f"\n{algorithm} Algorithm:\n"
        for metric, value in metrics.items():
            # Format the value to 2 decimal places if it's a float
            formatted_value = f"{value:.2f}" if isinstance(value, float) else str(value)
            formatted_text += f"- {metric}: {formatted_value}\n"
    
    return formatted_text

def clean_mongo_documents(doc):
    if isinstance(doc, list):
        return [clean_mongo_documents(item) for item in doc]
    if isinstance(doc, dict):
        return {key: clean_mongo_documents(value) for key, value in doc.items()}
    if isinstance(doc, ObjectId):
        return str(doc)
    return doc