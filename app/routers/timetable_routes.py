from fastapi import APIRouter, HTTPException
from app.utils.database import db
from app.generator.algorithms.ga.ga import *
from app.generator.algorithms.co.co_v2 import *
# from app.generator.rl.rl_train import *
from app.generator.rl.rl import generate_rl
import logging

router = APIRouter()

def evaluate():
    """
    Evaluate the timetables generated by different algorithms
    Returns a dictionary with algorithm names as keys and scores as values
    """
    # Get all timetables from the database
    timetables = list(db["Timetable"].find()) if "Timetable" in db.list_collection_names() else []
    
    # Group timetables by algorithm
    algorithms = {}
    for timetable in timetables:
        algorithm = timetable.get("algorithm")
        if algorithm not in algorithms:
            algorithms[algorithm] = []
        
        # Calculate a simple score based on number of activities
        activities = timetable.get("timetable", [])
        score = len(activities)
        algorithms[algorithm].append(score)
    
    return algorithms

def save_timetable(li, algorithm):
    """Save generated timetable to database with error handling"""
    # Don't try to save empty timetable data
    if not li:
        logging.warning(f"No timetable data to save for algorithm: {algorithm}")
        return False
        
    subgroups = [
        "SEM101", "SEM102", "SEM201", "SEM202",
        "SEM301", "SEM302", "SEM401", "SEM402"
    ]
    
    try:
        semester_timetables = {semester: [] for semester in subgroups}  

        for activity in li:
            # Make sure each activity has the algorithm field set
            if "algorithm" not in activity:
                activity["algorithm"] = algorithm
                
            subgroup_id = activity.get("subgroup", "SEM101")  # Default to SEM101 if not specified
            if subgroup_id in semester_timetables:
                semester_timetables[subgroup_id].append(activity)
            else:
                logging.warning(f"Unknown subgroup ID: {subgroup_id}")
                
        index = 0
        success = False
        
        for semester, activities in semester_timetables.items():
            try:
                result = db["Timetable"].replace_one(
                    {
                        "$and": [
                            {"semester": semester},
                            {"algorithm": algorithm}
                        ]
                    },
                    {
                        "code": generate_timetable_code(index, algorithm),
                        "algorithm": algorithm,
                        "semester": semester, 
                        "timetable": activities
                    },
                    upsert=True
                )
                if result.acknowledged:
                    success = True
                index += 1
            except Exception as e:
                logging.error(f"Failed to save timetable for semester {semester}: {str(e)}")
                
        return success
    except Exception as e:
        logging.error(f"Failed to save timetable for {algorithm}: {str(e)}")
        return False

#generate unique timetable codes for each algorithm and semester       
def generate_timetable_code(index, algorithm):
    return f"{algorithm}-TT000{index}"

@router.post("/generate")
async def generate_timetable():
    # Check if we have required collections in the database
    collections = db.list_collection_names()
    required_collections = ["days_of_operation", "periods_of_operation", "faculties", "modules", "Activities"]
    
    # Check for required collections with case-insensitive matching
    missing_collections = []
    for required in required_collections:
        found = False
        for collection in collections:
            if required.lower() == collection.lower():
                found = True
                break
        if not found:
            missing_collections.append(required)
    
    if missing_collections:
        error_msg = f"Missing required database collections: {', '.join(missing_collections)}"
        logging.error(error_msg)
        raise HTTPException(status_code=400, detail=error_msg)
    
    # Generate timetables with each algorithm
    logging.info("Starting timetable generation with multiple algorithms")
    
    results = {"GA": False, "CO": False, "RL": False}
    
    try:
        pop, log, hof, li = generate_ga()
        results["GA"] = save_timetable(li, "GA")
    except Exception as e:
        logging.error(f"GA algorithm failed: {str(e)}")
    
    try:
        sol = generate_co()
        results["CO"] = save_timetable(sol, "CO") 
    except Exception as e:
        logging.error(f"CO algorithm failed: {str(e)}")
    
    try:
        gen = generate_rl()
        results["RL"] = save_timetable(gen, "RL")
    except Exception as e:
        logging.error(f"RL algorithm failed: {str(e)}")
    
    # Evaluate results
    eval_results = evaluate()
    algorithm_scores = {}
    for algorithm, scores in eval_results.items():
        if scores:  # Check if there are any scores
            average_score = sum(scores) / len(scores)
            algorithm_scores[algorithm] = {
                "average_score": average_score,
            }
    
    # Check if at least one algorithm generated a timetable
    if not any(results.values()):
        logging.warning("All timetable generation algorithms failed")
        # Instead of failing with 500, return helpful message
        return {"message": "Failed to generate timetable. Check logs for details.", 
                "algorithms": results,
                "eval": algorithm_scores}
    
    return {"message": "Timetable generated", 
            "algorithms": results,
            "eval": algorithm_scores}

@router.get("/timetables")
async def get_timetables():
    timetables = list(db["Timetable"].find())
    cleaned_timetables = clean_mongo_documents(timetables)
    eval =  evaluate()
    for algorithm, scores in eval.items():
        average_score = sum(scores) / len(scores)
        eval[algorithm] = {
            "average_score": average_score,
        }
    
    out ={
        "timetables": cleaned_timetables,
        "eval": eval
    }
    
    return out

from bson import ObjectId

def clean_mongo_documents(doc):
    if isinstance(doc, list):
        return [clean_mongo_documents(item) for item in doc]
    if isinstance(doc, dict):
        return {key: clean_mongo_documents(value) for key, value in doc.items()}
    if isinstance(doc, ObjectId):
        return str(doc)
    return doc

@router.post("/select")
async def select_algorithm(algorithm: dict):
    """Endpoint to select an algorithm as the preferred one"""
    try:
        # Get the algorithm name from the request
        algorithm_name = algorithm.get("algorithm")
        if not algorithm_name:
            raise HTTPException(status_code=400, detail="Algorithm name is required")
            
        # Validate that it's one of our supported algorithms
        if algorithm_name not in ["GA", "CO", "RL"]:
            raise HTTPException(status_code=400, detail="Invalid algorithm. Must be one of: GA, CO, RL")
            
        # Check if we already have a selection document
        selection_exists = db["AlgorithmSelection"].find_one()
        
        if selection_exists:
            # Update existing selection
            result = db["AlgorithmSelection"].update_one(
                {"_id": selection_exists["_id"]},
                {"$set": {"selected_algorithm": algorithm_name}}
            )
        else:
            # Create new selection
            result = db["AlgorithmSelection"].insert_one(
                {"selected_algorithm": algorithm_name}
            )
            
        return {"message": f"Selected algorithm: {algorithm_name}", "success": True}
        
    except Exception as e:
        logging.error(f"Error selecting algorithm: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error selecting algorithm: {str(e)}")

@router.get("/selected")
async def get_selected_algorithm():
    """Endpoint to get the currently selected algorithm"""
    try:
        # Get the current selection
        selection = db["AlgorithmSelection"].find_one()
        
        if selection:
            return clean_mongo_documents(selection)
        else:
            # Default to GA if no selection exists
            return {"selected_algorithm": "GA"}
            
    except Exception as e:
        logging.error(f"Error getting selected algorithm: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error getting selected algorithm: {str(e)}")